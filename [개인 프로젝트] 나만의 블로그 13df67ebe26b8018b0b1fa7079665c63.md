# [개인 프로젝트] 나만의 블로그

## 요구 사항 정의서

[나만의 블로그 - 요구사항 정의서](https://www.notion.so/13ef67ebe26b807e98c4dcf8e13fc6db?pvs=21)

## ERD

- ERD 설계 (초반 대략적인 설계)
    
    [https://dbdiagram.io/d/67331d16e9daa85aca251981](https://dbdiagram.io/d/67331d16e9daa85aca251981)
    
    ![image.png](image.png)
    

## 패키지 설계

```
// src/main 하위에..	
	java
	 ㄴ com
	     ㄴ myblog 
	         ㄴ domain
		           ㄴ users
			             ㄴ controller  
				           ㄴ service
				           ㄴ repository - 레포지토리
				           ㄴ domain - Role.java, User.java 
					         ㄴ dto - UserRegisterForm, UserUpdatedForm
				           ㄴ exception
		           ㄴ posts
		               ㄴ controller
			             ㄴ Service
			             ㄴ dao
			             ㄴ Item
			             ㄴ exception
	         
	         ㄴ global
	             ㄴ auth (후에 security 적용..)
	             ㄴ common
	             ㄴ util
	         
	         ㄴ web
			         ㄴ login
			         ㄴ validation ...
			         HomeController.java
```

### 4. 회원가입 기능 + 유효성 검사 + 검증

구현한 것

- 회원가입 기능
    
    URL 흐름
    
    GET /myblog에서 회원가입 버튼 누르면 → GET /myblog/userreg (회원가입 폼 입력)
    
    → 회원가입 버튼누르면 → POST /userreg
    
    POST /userreg 에서 유효성 검사 + 검증 성공하면 회원가입, 실패하면 회원가입 폼 다시 입력하게끔
    
    ```
    참고 코드
    ㄴ java
    
    	org.myblog 
    		ㄴ domain.user
    			ㄴ domain - Role.java, User.java (깔끔한 엔디티만)
    		
    			ㄴ dto
    				ㄴ UserRegisterForm - 회원가입 폼 유효성 검사 (bean validation)
    			
    			ㄴ repository
    				ㄴ UserRepository - UserService 비즈니스 로직을 위한 JpaRepository extends
    			
    			ㄴ Service
    				ㄴ UserService - 비밀번호 확인, 아이디 중복, 이메일 중복 검사 로직 추가
    			
    		
    		ㄴ web.register
    				ㄴ RegisterController - UserService의 비즈니스 로직 실패하면, bindingResult에 FieldError, ObjectError 추가
    		
    
    ㄴ resources
    		ㄴ register
    				ㄴ registerForm.html - 모델 바인딩 & 에러메시지 출력
    ```
    
    ```
    POST /userreg에서 검증한 것
    1. DTO - UserRegisterForm - 빈 유효성 검사 (NotBlank, Email)
    
    2. 비밀번호 확인 (password - passwordCheck 가 일치하는지)
    
    3. 아이디 중복 검사
    
    4. 이메일 중복 검사
    
    5. 기타
    	-- DTO로 받은 객체를, 온전한 엔디티로 변환해주고
    	-- 엔디티를 데이터베이스 테이블("users")에 넣기
    ```
    

걸리는 내용

- POST /userreg 에서 일단 ROLE_USER는 Role.ROLE_USER (일반 유저)로 해둠

### 5. 로그인 기능

- 로그인 기능
    
    URL 흐름
    
    GET /myblog 에서 로그인 버튼 누르면
    
    → GET /loginform → 해당 뷰에서 로그인 버튼 누르면
    
    → POST /login
    
    → 로그인성공하면, redirect:/
    
    → 로그인실패하면, 다시 login/loginForm.html 뷰로 가서 에러메시지 보여줌
    
    homeController
    
    GET / → redirect :/myblog
    
    GET myblog
    
    → 세션에 로그인정보가 있어야만 login/loginhome.html 뷰로 가서 사용자 정보 / 로그아웃 버튼 보여줌
    
    → 로그인정보 없으면, home.html 뷰로 가서 로그인 / 회원가입 버튼 보여줌
    
    ```
    고친 코드
    
    ㄴ java
    
    	org.myblog 
    		
    			ㄴ dto
    				ㄴ UserLoginForm - Login DTO bean validation 적용
    			
    			ㄴ repository
    				ㄴ UserRepository - UserService 비즈니스 로직을 위한 
    						existsByUsername, existsByEmail, findByUsername 메서드 추가
    			
    			ㄴ Service
    				ㄴ UserService - 로그인성공여부, 로그인성공하면 DB에 저장함수, findByUsername함수
    			
    		
    		ㄴ web.login
    				ㄴ sessionConst - 세션Id 상수화시켜서 따로 저장
    				ㄴ LoginController 
    					- 로그인 폼 요청, 
    					- 실제 로그인 기능 
    						(로그인성공여부, 로그인실패시 에러메시지, 로그인 성공시 세션 만들기) 
    					- 로그아웃 기능
    		
    
    ㄴ resources
    		ㄴ login
    				ㄴ loginForm.html - 모델 바인딩 & 에러메시지 출력
    				ㄴ loginhome.html - 로그인성공시, 세션에 저장된 데이터 출력 
    		
    		ㄴ home.html - 세션데이터 존재 안하면, home 뷰로
    ```
    

### 6. 필터링, 인터셉터 기능

---

- 로그인한 사용자만, 메인화면으로 갈 수 있게끔.
- 로그인 안한 사용자는, 아래 url만 접근할 수 있게끔.
    
    ```
    /, /myblog, /myblog/userreg, 
    /myblog/loginform, /myblog/login
    ```
    
    로그인 안한 사용자는 위 url만 접근가능하고, 그이외의 url 접근 시 로그인으로 redirect
    
- 로그인안한 사용자가 로그인한 이후에는, 다시 그 사용자가 원래 가려던 페이지로 redirect 구현
    - 코드
        
        ```java
        // 인터셉터 설정
        
        public class LoginCheckInterceptor implements HandlerInterceptor {
            @Override
            public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                                     Object handler) throws Exception {
                String requestURI = request.getRequestURI();
        
                HttpSession session = request.getSession(false);
        
                // 세션 자체가 없어도, 세션은 있는데 해당 세션ID가 없어도..
                if (session == null || session.getAttribute(SessionConst.User_Login_Form) == null) {
                    // 로그인 안한 사용자임
        
                    // 로그인으로 redirect
                    response.sendRedirect("/myblog/loginform?redirectURL=" + requestURI);
        
                    return false; // 그다음 단계 못감!! (redirect만 실행될뿐..)
                }
        
                return true; // 로그인 인증 성공!! -- 그다음단계 (컨트롤러 호출 - 뷰 리턴 - postHandle - 뷰 렌더링 - afterCompletion)
            }
        }
        
        // GET /loginform에서 쿼리파라미터로 받아온 redirectURL을 모델에 추가
          @GetMapping("/loginform")
          public String loginForm(@RequestParam(value = "redirectURL", required = false) String redirectURL,
                                  Model model){
              model.addAttribute("userLoginDTO", new UserLoginForm());
              model.addAttribute("redirectURL", redirectURL); // 로그인 폼에 redirectURL 추가..
              return "login/loginForm"; // 로그인 폼 요청
          }
         
        // 해당 모델을, '폼'에서 hidden 속성으로 받음
         <!-- 로그인 폼 -->
                <form action="/myblog/login" method="post" th:object="${userLoginDTO}">
        
                    <!-- input hidden으로 redirectURL 보내기 -->
                    <input type="hidden" name="redirectURL" th:value="${redirectURL}">
        
        // 로그인처리
        // @RequestParam은 쿼리 파라미터는 물론 '폼데이터로 전달된 값'도 받아온다 !!
            @PostMapping("/login") // 실제 로그인 기능
            public String login(@Validated @ModelAttribute("userLoginDTO")UserLoginForm form,
                                @RequestParam(value = "redirectURL", defaultValue = "/") String redirectURL,
                                BindingResult bindingResult, HttpServletRequest request){
        
                //log.info("loginform : {}", form);
        
                UserLoginForm userLoginForm = userService.login(form.getUsername(), form.getPassword());
        
                if (userLoginForm == null) {
                    // 로그인 실패했으면, 에러메시지를 bindingResult에 추가해줄 것
                    bindingResult.reject("totalLoginError", "아이디 또는 비밀번호가 일치하지 않습니다.");
                }
        
                if (bindingResult.hasErrors()) {
                    log.info("bindingResult : {}", bindingResult);
                    return "login/loginForm"; // 다시 로그인 폼으로 가서, 에러메시지 보여줄 것
                }
        
                // 로그인 성공 처리 - 서블릿이 제공하는 HttpSession 적용 !!
        
                // 세션이 있으면 있는 세션 반환, 없으면 신규 세션 생성 (디폴트값 true)
                HttpSession session = request.getSession();
        
                // 세션 id - (SessionConst에 상수화한 "userLoginForm")
                // 세션 value - userLoginForm 객체
                session.setAttribute(SessionConst.User_Login_Form, userLoginForm);
        
                return "redirect:" + redirectURL;
            }
        ```
        
    
    이때, @RequestParam은 쿼리 파라미터 또는 폼 데이터로 전달된 값도 가져온다!! 즉, 폼데이터로 input hidden으로 값을 받을 수 있다는 의미임 !!
    
    → 아니 이 코드 추가했더니 무슨,, url 매핑 꼬인 거 같음.. 일단 패스 
    

걸리는 내용

- 유저 권한에 따른 컨트롤러 ? (p.23)
    
    → 인터셉터를 이용해서, 유저 권한별로 접근 가능한 페이지 다르게 하는 로직 ?
    

---

## 메인화면 부분

### 1. 내 벨로그 생성 - 0621

- 구현한 내용
    - 로그인 안한 상태
        - 로그아웃 안한 상태에서는 화면에 ‘로그인’, ‘회원가입’ 버튼만
            
            ![Untitled](Untitled.png)
            
    - 로그인한 상태
        - 로그인한이후, ‘내 벨로그 생성’ 폼을 요청해, 내 벨로그를 생성해준다 (Blog 엔디티)
            - 이때, 이미 내 벨로그가 존재한다면 바로 loginhome 뷰로 가준다.
                
                ![Untitled](Untitled%201.png)
                
        - 내 벨로그를 생성한 이후에야, 기타 기능 버튼(내벨로그, 새글작성,설정, 로그아웃..)이 뜬다.
            
            ![Untitled](Untitled%202.png)
            
- 구현코드 및 결과
    - 구현코드 (핵심 부분 위주)
        - `homeController`
            
            ```
            로그인 X -> home.html (로그인전 페이지)
            
            로그인 O , 벨로그 X -> rediect:/blog/createblog (블로그 생성 페이지로 리다이렉션)
            
            로그인 O, 벨로그 O -> login/loginhome.html
            ```
            
            - 코드
                
                ```java
                @Controller
                @RequiredArgsConstructor
                public class HomeController {
                
                    private final UserService userService;
                
                    @GetMapping("/")
                    public String root(){
                        return "redirect:/myblog";
                    }
                
                    @GetMapping("/myblog")
                    public String home(
                            @SessionAttribute(name = SessionConst.User_Login_Form, required = false)UserLoginForm userLoginForm,
                            Model model){
                        // 세션에 데이터가 없으면 home 뷰로 -- 로그인 안된 상태
                        if (userLoginForm == null){
                            return "home"; // 로그인 전 페이지
                        }
                
                        // 세션에 데이터가 있다면 -- 로그인된 사용자 정보를 blog 뷰에 띄우기 위해..
                        User foundUser = userService.findByUsername(userLoginForm.getUsername()); // 유저 DTO말고 엔디티를 넘겨주기.
                        model.addAttribute("user", foundUser);
                
                        // 벨로그 생성여부에 따라, 페이지 분기
                        if (foundUser.getBlog() == null){
                            return "redirect:/myblog/createblog"; //  블로그 생성 페이지로 리다이렉션
                        }
                        return "login/loginhome"; // 로그인 O, 블로그 O -> loginhome 뷰
                    }
                ```
                
        - BlogController
            
            ```
            -- GET /myblog/createblog
            	-- 블로그 폼 요청
            	-- 블로그 생성용 DTO 생성
            
            -- POST /myblog/createblog
            	-- 블로그 생성용 DTO bean validation 추가
            	-- ** Blog 생성 ** 
            			특히 이때, Blog에 연결된 1:1 User 엔디티를 받아와야 함
            			(이때, 세션에 등록한 userLoginFrom DTO -> 온전한 User 엔디티로 변환시켜주기 위해,
            			userService의 findByUsername 메서드 사용)
            ```
            
            - 코드
                
                ```java
                @Controller
                @RequestMapping("/myblog")
                @RequiredArgsConstructor
                @Slf4j
                public class BlogController {
                
                    private final UserService userService;
                    private final BlogService blogService;
                    @GetMapping("/blogs")
                    public String blogForm(Model model){
                        model.addAttribute("blogCreateForm", new BlogCreateForm());
                        return "blog/blogForm";
                    }
                
                    @PostMapping("/blogs")
                    public String createBlog(@Validated @ModelAttribute("blogCreateForm")BlogCreateForm form,
                                             BindingResult bindingResult,
                                             @SessionAttribute(name = SessionConst.User_Login_Form, required = false)UserLoginForm userLoginForm){ // 블로그 생성
                
                        log.info("Blog : {}", form); // -- 블로그 폼 잘 전달받았는지..
                        log.info("Session으로부터 받은 유저 로그인 정보 : {} ", userLoginForm);
                
                        if (bindingResult.hasErrors()){
                            return "redirect:/myblog/blogs"; // 타이틀 다시 입력하게끔
                        }
                
                        Blog blog = new Blog();
                        blog.setTitle(form.getTitle());
                        blog.setUser(userService.findByUsername(userLoginForm.getUsername())); // 세션에 저장된 유저name을 기반으로, 블로그에 유저 넣어주기
                        blog.setPosts(null); // 아직 새 블로그를 만드는 단계인데, 포스트가 있을리 없음
                
                        blogService.saveBlog(blog);
                
                        // 블로그 생성 완료 (로그인 O, 블로그 생성 완 O)
                        return "login/loginhome"; // 그제서야 기타 기능 사용 가능 !!
                    }
                }
                ```
                
        - Blog 엔디티를 생성할 때, @CreatedDate가 작동하지 않아, 실제생성시간이 아닌 null 값이 들어갔다..
            
            https://sowon-dev.github.io/2021/11/29/211130Jpa-auditing/#google_vignette
            
    - 성공적으로 들어온 Blog (1:1 매핑된 User값도, 생성시간도 잘 담김)
        
        ![Untitled](Untitled%203.png)
        
        ![Untitled](Untitled%204.png)
        
    

### 2. 드롭다운 - 기타 기능 구현 - 0622 ~

- 부트스트랩 dropdown이 적용이 안될때 !!

https://coding-dahee.tistory.com/50

![Untitled](Untitled%205.png)

- 로그아웃 → 이미 앞서 구현함. POST /myblog/logout 이랑 매핑했음
- 설정 →  /settings
    - 화면구성
        
        ![Untitled](Untitled%206.png)
        
    - 구현과정 & 코드
        1. @OneToOne 매핑을 사용하여 Blog와 User를 매핑하고, Blog 생성 시 setUser 메서드를 통해 유저를 설정해주었더니, JPA에서 이를 자동으로 인식하고 해당 유저의 Blog 필드에도 값을 채워주었다!!
            - 코드
                
                ```java
                // User 엔디티 일부분
                @Entity
                @Table(name = "users")
                @Getter @Setter
                @NoArgsConstructor
                public class User {
                    @Id
                    @GeneratedValue(strategy = GenerationType.IDENTITY)
                    private Long id;
                
                    private String username;
                
                    private String password;
                
                    private String name;
                
                    private String email;
                
                    private String image; // 사용자 프로필 링크
                
                    @Enumerated(EnumType.STRING)
                    private Role role;
                
                    // User 테이블 필드 완
                    // users 테이블과 다른 테이블간의 관계매핑변수
                     // users - blogs 테이블 1:1 관계
                    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
                    private Blog blog;
                  }
                  
                  // Blog 엔디티
                  @Entity
                @Table(name = "blogs")
                @Getter @Setter
                @NoArgsConstructor
                @EntityListeners(AuditingEntityListener.class)
                public class Blog {
                    @Id
                    @GeneratedValue(strategy = GenerationType.IDENTITY)
                    private Long id;
                
                    @OneToOne
                    @JoinColumn(name = "user_id")
                    private User user;
                
                    private String title;
                
                    @Column(name = "created_at")
                    @CreatedDate
                    private LocalDateTime createdAt; // 생성날짜를 자동으로 매핑시켜주고 싶은 엔디티에 사용하면 됨
                
                    @OneToMany(mappedBy = "blog")
                    private List<Post> posts;
                }
                
                // Blog 생성시, setUser에 값을 채워줌
                // -- BlogController 일부
                    @PostMapping("/createblog")
                    public String createBlog(@Validated @ModelAttribute("blogCreateForm")BlogCreateForm form,
                                             BindingResult bindingResult,
                                             @SessionAttribute(name = SessionConst.User_Login_Form, required = false)UserLoginForm userLoginForm){ // 블로그 생성
                
                        log.info("Blog : {}", form); // -- 블로그 폼 잘 전달받았는지..
                        log.info("Session으로부터 받은 유저 로그인 정보 : {} ", userLoginForm);
                
                        if (bindingResult.hasErrors()){
                            return "redirect:/myblog/createblog"; // 타이틀 다시 입력하게끔
                        }
                
                        Blog blog = new Blog();
                        blog.setTitle(form.getTitle());
                        blog.setUser(userService.findByUsername(userLoginForm.getUsername())); // 세션에 저장된 유저name을 기반으로, 블로그에 유저 넣어주기
                        blog.setPosts(null); // 아직 새 블로그를 만드는 단계인데, 포스트가 있을리 없음
                
                        blogService.saveBlog(blog);
                
                        // 블로그 생성 완료 (로그인 O, 블로그 생성 완 O)
                        return "login/loginhome"; // 그제서야 기타 기능 사용 가능 !!
                    }
                 
                 // 그랬더니...
                 // user의 blog 필드가 자동으로 채워진 것을 확인할 수 있었다 !!
                 
                 // -- 참고, SettingController log
                 @Controller
                @RequiredArgsConstructor
                @Slf4j
                public class SettingController {
                
                    private final UserService userService;
                    @GetMapping("/settings")
                    public String settingForm(
                            @SessionAttribute(name = SessionConst.User_Login_Form, required = false) UserLoginForm userLoginForm
                            ,Model model){
                
                        User user = userService.findByUsername(userLoginForm.getUsername());
                        model.addAttribute("user", user);
                
                        log.info("User : {}", user);
                        log.info("User - blog : {}", user.getBlog().getTitle());
                
                        return "setting/settingForm";
                    }
                }
                ```
                
        
        1. User 정보수정 
            
            restful api url 규칙을 사용하기 위해, 유저 정보를 수정하는 url을 아래와 같이 정했다.
            
            PATCH — /users/{id}
            
            그런데 문제 발생했다. HTML 폼에서는 기본적으로 POST, GET 메서드를 지원한다. 
            
            그래서 PATCH 메서드를 사용하려면, 폼을 POST로 전송하고 + 서버에서는 PATCH 요청으로 처리하도록 해줘야 한다. 
            
            이때, 스프링에서 제공해주는 HiddenHttpMethodFilter와 input 태그 안에 숨겨진 _method 필드를 사용하면 된다 !!
            
            https://cornarong.tistory.com/56
            
            - 코드 - 이때, 어쨌든 html 뷰에 form 태그 method = post 로 등록은 해둬야 됨 !!
                
                ```java
                // WebConfig -- hiddenHttpMethodFilter 추가
                @Configuration
                public class WebConfig implements WebMvcConfigurer {
                
                    // 로그인 처리를 위한 인터셉터
                    @Override
                    public void addInterceptors(InterceptorRegistry registry) {
                        registry.addInterceptor(new LoginCheckInterceptor())
                                .order(1)
                                .addPathPatterns("/**")
                                .excludePathPatterns(
                                        "/", "/myblog", "/myblog/userreg", "/myblog/loginform",
                                        "/myblog/login",
                                        "/css/**", "/resources/**", "/*.ico", "/error"
                                );
                    }
                
                    // HiddenHttpMethodFilter 등록 !!
                    @Bean
                    public HiddenHttpMethodFilter httpMethodFilter(){
                        HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter();
                
                        return hiddenHttpMethodFilter;
                    }
                }
                ```
                
                ```html
                -- editUser.html 뷰 일부
                <form th:action="@{/users/{id}(id=${user.id})}" method="post" th:object="${user}">
                   <input type="hidden" name="_method" value="patch">
                ```
                
            
            실제로는 POST 요청인데, HiddenHttpMethodFilter로 서버에서 POST 요청을 PATCH, PUT, DELETE 등으로 처리할 수 있도록 한 것 !!
            
        2. 이메일주소 → 변경
        3. 이메일수신설정 → 체크박스 값 토글처리
            - User 엔디티에 댓글알림여부, 업데이트 알림 여부 Boolean 변수 추가
            - 이메일 수신 설정을 토글로 선택할 수 있도록 하고, 유저 엔티티의 Boolean 값을 업데이트
                
                → RequestParam 어노테이션은 폼데이터의 payload와 쿼리파라미터를 받아주니까, 굳이 GET 으로 바꾸는 폼 만들지 않아도 됨 !!
                
                → 체크박스 값 넘기기 https://blogshine.tistory.com/193
                
                - 정리
                    
                    일반적인 HTML 폼에서 체크박스 처리는 다음과 같이 한다.
                    
                    ![Untitled](Untitled%207.png)
                    
                    판매오픈 체크박스를 선택할 경우,
                    
                    HTML form에서 open=on 값을 넘겨주고 → 스프링에서 on이라는 문자를 true로 바꿔줌.
                    
                    즉, [`item.open](http://item.open) = true` // 체크박스를 선택한 경우
                    
                    반면, 판매오픈 체크박스를 선택하지 않을 경우,
                    
                    [`item.open](http://item.open) = null` 
                    
                    open 필드값이 아예 서버로 전송되지 않는다.
                    
                    즉, 체크박스를 체크할 경우에만, open이라는 필드가 서버로 와서 true 값으로 변경해준다.
                    
                    체크를 했을 경우 true, 아니면 false 제대로 값이 넘어와야 서버가 명확히 처리를 하는데, 그러지 못한다..
                    
                    이에 스프링은 히든필드 `_open=on`을 항상 보내서, 히든필드만 있는 경우 false로 히든필드와 open=on이 같이 있을 경우, true로 값을 변경해준다.
                    
                    ![Untitled](Untitled%208.png)
                    
                    이를 타임리프 문법으로 표현하면 다음과 같다.
                    
                    ![Untitled](Untitled%209.png)
                    
                    타임리프의 th:field 를 추가해주면 알아서 처리해준다 !!
                    
                    그래서 내가 추가한 코드
                    
                    ```html
                    -- settingForm.html 일부
                    <!-- 이메일 수신 설정 -->
                    <form th:action="@{/users/{id}/notification-settings(id=${user.id})}" method="post" th:object="${user}">
                        <input type="hidden" name="_method" value="patch">
                    
                        <div class="form-group">
                            <label>이메일 수신 설정</label>
                            <div class="toggle">
                                <input type="checkbox" id="commentNotification" name="commentNotification"
                                th:field="*{commentNotification}">
                                <label for="commentNotification">댓글 알림</label>
                            </div>
                            <div class="toggle">
                                <input type="checkbox" id="updateNotification" name="updateNotification"
                                th:field="*{updateNotification}">
                                <label for="updateNotification">벨로그 업데이트 소식</label>
                            </div>
                        </div>
                        <div class="form-group">
                            <button type="submit" class="btn btn-secondary">수신설정 변경</button>
                        </div>
                    </form>
                    ```
                    
                    ```java
                    // UserController
                    
                        @PatchMapping("/users/{id}/notification-settings")
                        public String updateNotificationSettings(@PathVariable Long id,
                             @RequestParam(name="commentNotification", required = false) boolean commentNotification,
                             @RequestParam(name="updateNotification", required = false) boolean updateNotification){
                    
                            log.info("댓글 알림 여부 : {}", commentNotification);
                            log.info("업데이트 여부 : {}", updateNotification);
                    
                            User foundUser = userService.findById(id);
                            foundUser.setCommentNotification(commentNotification);
                            foundUser.setUpdateNotification(updateNotification);
                    
                            userService.saveUser(foundUser); // 없으면 insert, 있다면 update
                    
                            return "redirect:/settings";
                        }
                    ```
                    
        4. 회원탈퇴
            - 해야 할 일
                
                ```
                1. settingForm 뷰에서 회원탈퇴 누르면, 
                	GET 요청으로 "정말 지우시겠습니까?"에서
                		취소 버튼 -> 다시 settings 으로 redirect
                		확인 버튼 -> DELETE /users/{id} url로 보내준다. 
                
                2. 컨트롤러에서 DELETE 요청 처리
                		- 해당 사용자 엔디티를 식별해, 데이터베이스에서 삭제한다.
                		- 그리고 난뒤 /logout으로 redirect 
                			(/logout은 세션 로그아웃 후에, redirect:/ 해줌 )
                ```
                
            
            - 구현
                - Controller에서 POST, DELETE 도 rest api에 맞게 추가했다.
                - `HTML 에서는` form 태그로 GET, POST 태그만 보낼 수 있다.
                    
                    그렇기에 각각 원하는 메서드를 보내기 위한 방법은 총 2가지였다.
                    
                    1. (앞서 정리한)  HiddenHttpMethodFilter와 input 태그 안에 숨겨진 _method 필드 사용
                    2. JavaScript에서 fetch함수 사용할 것 ! - redirect
                        - `코드`
                            - html - JS에서 fetch함수로 어떤 HTTP method와 url을 보낼 지 설정해줌!!
                                
                                ```html
                                -- SettingForm에서 회원탈퇴부분
                                  <!-- 회원 탈퇴 -->
                                    <div class="form-group">
                                        <!-- hidden input을 사용해 데이터 전달 !!-->
                                        <input type="hidden" id="userId" th:value="${user.id}">
                                        <button type="submit" class="btn btn-danger"
                                            onclick="confirmDelete()">회원 탈퇴</button>
                                    </div>
                                
                                    <script>
                                        function confirmDelete() {
                                            if (confirm("정말로 회원 탈퇴하시겠습니까?")) {
                                                const id = document.getElementById('userId').value;
                                
                                                fetch(`/users/${id}`, {
                                                    method: 'DELETE',
                                                    headers: {
                                                        'Content-Type': 'application/json'
                                                        // 필요에 따라 다른 헤더를 추가할 수 있습니다.
                                                    },
                                                    // body: JSON.stringify(data), // DELETE 메소드는 body를 보내지 않는 것이 일반적입니다.
                                                })
                                                .then(response => {
                                                    if (!response.ok) {
                                                        throw new Error('네트워크 상태가 불안정합니다.');
                                                    }
                                                     // DELETE /users/{id}에서 response 상태가 ok라면..
                                                    // 회원 삭제 후 로그아웃 처리를 위한 POST 요청을 보낸다.
                                                    return fetch('/myblog/logout', {
                                                        method: 'POST',
                                                        headers: {
                                                            'Content-Type': 'application/json'
                                                            // 필요에 따라 다른 헤더를 추가할 수 있습니다.
                                                        },
                                                    });
                                                })
                                                .then(response => {
                                                    if (!response.ok) {
                                                        throw new Error('네트워크 상태가 불안정합니다.');
                                                    }
                                                    // 로그아웃 성공 시 처리할 작업을 추가할 수 있습니다.
                                                    window.location.href = "/"; // 로그아웃 후 리다이렉트할 경로 설정
                                                })
                                  
                                            } else {
                                                // 취소 버튼 클릭 시, 다시 /settings 로 redirect
                                                window.location.href = "/settings";
                                            }
                                        }
                                    </script>
                                ```
                                
                            - 컨트롤러
                                - UserController
                                    
                                    ```java
                                        @DeleteMapping("/users/{id}")
                                        public ResponseEntity<String> deleteUser(@PathVariable Long id){
                                            User foundUser = userService.findById(id);
                                    
                                            log.info("id : {}", id);
                                            log.info("foundUser : {}", foundUser);
                                    
                                            userService.deleteUser(id);
                                    
                                            return ResponseEntity.ok().build();
                                        }
                                    ```
                                    
                                - LoginController
                                    
                                    ```java
                                    @PostMapping("/logout")
                                    public String logout(HttpServletRequest request){
                                        // 세션 삭제
                                    
                                        HttpSession session = request.getSession(false);
                                            // 세션이 있으면 기존 세션 반환, 없으면 null 반환
                                    
                                        if (session != null){
                                            session.invalidate(); // 세션 제거
                                        }
                                    
                                        return "redirect:/";
                                    }
                                    ```
                                    
                            
        5. 프로필 사진 업로드 / 삭제
            
            https://velog.io/@minjiki2/파일-업로드 - 이 강의안 참고
            
            ```
            domain 수정 - 내가 정의한 클래스를 엔디티의 필드로 만듦
            	- user 엔디티에 @Embedded 타입으로 UploadFile형 추가
            	- @Embeddable UploadFile (고객저장파일명, 서버내부관리파일명)
            
            application.properties - 파일 환경변수 설정
            
            file 패키지 코드
            	- FileStore
            			UploadFile storeFile(Multipartfile)
            			-> 이 함수에서, 내 로컬서버에 파일자체를 저장하고 +
            				 임베디드타입인 UploadFile을 리턴
            			-> 원래라면, AWS의 S3 같은 곳에 파일자체를 저장하고,
            								 데이터베이스에서는, 파일경로/기타정보 만 저장
            	
            	- FileController 와 settingForm.html 뷰 (프로필 설정, 업데이트 / 삭제부분) 
            		 - 사용자지정파일 업로드, 프로필 이미지 보여주는 컨트롤러
            ```
            
            - settingForm.html 뷰 - 추가한 부분만
                
                ```html
                <div class="container">
                    <div class="profile-header">
                        <img th:src="@{'/images/' + ${user.profileFile.storeFileName}}" alt="Profile Picture"> <!-- 이미지 업로드한 파일 불러오기 !! GET - /images/${filename} -->
                        <h1 th:text="${user.username}">username</h1>
                        <form th:action="@{/users/{id}/username(id=${user.id})}">
                            <button class="edit-btn" type="submit" style="margin-left: 20px;">수정</button>
                        </form>
                    </div>
                
                    <div>
                        <form id="profileUploadForm" th:action="@{/users/{id}/profile-image(id=${user.id})}" method="post" enctype="multipart/form-data">
                            <div class="form-group">
                                <input id="profileImage" type="file" name="profileImage" class="file-input" onchange="document.getElementById('profileUploadForm').submit();">
                                <button type="button" class="btn btn-primary" onclick="document.getElementById('profileImage').click();">이미지 업로드</button>
                            </div>
                        </form>
                
                        <form id="profileRemoveForm" th:action="@{/users/{id}/profile-image(id=${user.id})}" method="post">
                            <input type="hidden" name="_method" value="delete">
                            <button type="submit" class="btn btn-secondary">이미지 제거</button>
                        </form>
                    </div>
                
                    <script>
                        document.getElementById('profileImage').addEventListener('change', function() {
                            if (this.files.length > 0) {
                                document.getElementById('profileUploadForm').submit();
                            }
                        });
                    </script>
                
                ```
                
                - GET /images/{filename} 컨트롤러에서, 서버내 파일을 찾아서 웹브라우저에 보여줌
                - POST /users/{id}/profile-image 컨트롤러에서, 선택한 파일자체를 내 로컬서버에 저장하고 + DB에는 user의 UploadFile형 update
                
    
    주로, 버튼을 누르고 링크를 움직여야 할 때가 많음. onclick을 쓰면 편리하다 !!!
    
    https://ay9318.tistory.com/32
    
    ```html
    <button class="w-100 btn btn-dark btn-lg" onclick="location.href='items.html'"
            th:onclick="|location.href='@{/login}'|" type="button">
        로그인
    </button>
    ```
    
    → settingform에서 너무 많은 form 태그를 남용함. 
    
    후에 다른 프로젝트할 때는 form 태그보다도, button + JavaScript의 fetch함수를 써서 더 좋은 코드로 리팩토링하자
    
- 새글작성 → /myblog/writeform -
    - 요구사항
        
        ```
        요구사항 (블로그 포스트)
        • 사용자는 임시 글을 작성할 수 있습니다.
        • 사용자는 글을 작성하자 마자 즉시 출간할 수 있습니다.
        • 사용자는 임시 글 목록을 볼 수 있습니다.
        • 글을 작성할 때 이미지, URL 등을 포함시킬 수 있습니다.
        • 글은 제목, 내용, 태그들을 작성할 수 있고 자동으로 작성일이 지정됩니다. (제목,
        내용은 필수 입니다.)
        • 임시 글 목록에서 임시 글을 삭제할 수 있습니다.
        • 임시 글은 수정할 수 있습니다. 수정 후 바로 출간할 수 있습니다.
        ```
        
    - writeForm.html 에서 첫번째 Post 내용 채우기 - 0703 완성!
        - Tag 엔디티에 태그 등록 먼저
        - Post 컨트롤러에서, 등록된 태그엔디티를 참조해, 해당 글의 태그까지 insert
        - 그러면, Tag 엔디티 / Post 엔디티 / Post_Tag 엔디티 모두 값 설정 완료
            
            ```
            POST (id).   TAG (tagname)       Post_Tag (postid - tagid 매핑)
            1             SQL (19번)          1 : 19   
            2             C++ (20번)          2 : 20
            3             SQL (19번)          3 : 19
            ```
            
        - 태그 삭제에 대한 고민
            
            ```
            처음에 writeform에서 'x' 버튼을 누르면, Tag 엔디티에서 deleteByTagname으로 
            아예 태그 테이블의 태그를 지우게 했다.
            
            하지만, 특정 글에서 태그를 삭제할 때 해당 태그가 다른 글에서도 사용중이라면,
            그 태그도 함께 삭제될 수 있다. 이는 의도치 않은 결과를 초래할 수 있다.
            
            따라서, 태그를 글과 연결하는 방식과 태그를 삭제하는 방식을 명확하게 정의할 필요가 있습니다. 
            
            해결책: 태그-글 관계 관리
            태그-글 관계 테이블 추가: 
            	태그와 글 사이의 관계를 관리하는 별도의 테이블을 생성합니다. 
            	예를 들어, PostTag와 같은 테이블을 만들어 태그와 글 간의 연결을 저장합니다.
            	
            태그 삭제 로직 변경: 
            	특정 글에서 태그를 삭제할 때는 PostTag 테이블에서 해당 글과 태그 간의 연결만 삭제합니다. 
            	그리고 특정 태그가 더 이상 다른 글에서도 사용되지 않는다면, 그 때 해당 태그를 삭제합니다.
            
            또한 태그 삭제 로직뿐만 아니라, 추가부분도 POST_TAG 연관엔디티에서 처리해줘야 한다!!
            	그러나 전체적인 흐름에서 태그 추가와 삭제는 연관 테이블에서 관리되기 때문에, 
            	태그 자체를 추가/삭제하는 것과 포스트에 태그를 추가/삭제하는 것은 구분되어야 합니다. 
            	이렇게 하면 중복된 태그가 생기지 않고, 효율적으로 태그를 관리할 수 있습니다.
            
            논리흐름 꼬임 !!
            	-> postId가 생성된 이후에, Tag 추가/삭제 가능하게끔 !!!
            	
            	-> 게시물 생성과 태그 추가를 하나의 폼에서 처리합니다.
            	-> 서버에서 게시물을 저장한 후, 태그를 저장하고 연관 테이블에 데이터를 추가합니다.
            	
            결론, 내가 너무 복잡하게 생각했다 !!
            => 굳이 ajax를 이용해서 폼을 2번 요청할 필요가 없이,
            	form에서 태그를 +버튼하면 태그가 배열에 더해지고, -버튼 누르면 태그가 배열에 안더해지고,
            	그걸 sumbit 버튼을 눌렀을 때, 해당 태그가 넘어가서
            		그 태그를 태그 엔디티에 설정해주고,
            		POST_TAG 엔디티 연관관계를 세팅해주면 되잖아 !!
            		애초에, 그걸 'x' 버튼을 누를 때마다, POST_TAG 연관관계를 삭제해준다는 게 개오바지...
            ```
            
            - 2차 지피티 제안
                - 1차
                    
                    ```java
                    package org.myblog.domain.post.controller;
                    
                    import lombok.RequiredArgsConstructor;
                    import lombok.extern.slf4j.Slf4j;
                    import org.myblog.domain.post.domain.Post;
                    import org.myblog.domain.post.dto.PostCreatedDto;
                    import org.myblog.domain.post.repository.PostRepository;
                    import org.myblog.domain.tag.domain.Tag;
                    import org.myblog.domain.tag.service.TagService;
                    import org.springframework.stereotype.Controller;
                    import org.springframework.ui.Model;
                    import org.springframework.web.bind.annotation.*;
                    
                    @Controller
                    @RequiredArgsConstructor
                    @Slf4j
                    public class PostController {
                    
                        private final TagService tagService;
                        private final PostRepository postRepository;
                    
                        @GetMapping("/writeform")
                        public String writeForm(Model model) {
                            model.addAttribute("postCreatedDto", new PostCreatedDto());
                            return "post/writeForm";
                        }
                    
                        @PostMapping("/writeform/next")
                        public String writeFormNext(@ModelAttribute PostCreatedDto postCreatedDto) {
                            log.info("postCreatedDto : {}", postCreatedDto);
                    
                            Post post = new Post();
                            post.setTitle(postCreatedDto.getTitle());
                            post.setContent(postCreatedDto.getContent());
                            post.setPublished(postCreatedDto.getPublished());
                    
                            postRepository.save(post);
                    
                            // Post가 생성된 후 해당 Post ID로 새로운 페이지로 리다이렉트
                            return "redirect:/writeform/next/" + post.getId();
                        }
                    
                        @GetMapping("/writeform/next/{postId}")
                        public String writeFormNextStep(@PathVariable Long postId, Model model) {
                            model.addAttribute("postId", postId);
                            return "post/writeFormNext";
                        }
                    
                        @PostMapping("/writeform/next/{postId}/addTag")
                        public ResponseEntity<Void> addTagToPost(@PathVariable Long postId, @RequestBody Tag tag) {
                            Post post = postRepository.findById(postId).orElseThrow(() -> new IllegalArgumentException("Invalid post ID"));
                            Tag savedTag = tagService.saveTag(tag);
                            post.addTag(savedTag);
                            postRepository.save(post);
                            return ResponseEntity.ok().build();
                        }
                    
                        @DeleteMapping("/writeform/next/{postId}/removeTag/{tagId}")
                        public ResponseEntity<Void> removeTagFromPost(@PathVariable Long postId, @PathVariable Long tagId) {
                            Post post = postRepository.findById(postId).orElseThrow(() -> new IllegalArgumentException("Invalid post ID"));
                            Tag tag = tagService.findById(tagId);
                            post.removeTag(tag);
                            postRepository.save(post);
                            return ResponseEntity.ok().build();
                        }
                    }
                    
                    ```
                    
                    ```html
                    <!DOCTYPE html>
                    <html lang="en" xmlns:th="http://www.thymeleaf.org">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
                        <title>글쓰기 폼</title>
                        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
                        <style>
                            /* 스타일링 생략 */
                        </style>
                    </head>
                    <body>
                    
                    <div class="editor-container">
                        <form id="postForm" th:action="@{/writeform/next}" th:object="${postCreatedDto}" method="post">
                            <input type="text" class="editor-title" placeholder="제목을 입력하세요" name="title" th:field="*{title}" required>
                            <input type="text" class="editor-tags" id="tagInput" placeholder="태그를 입력하세요">
                            <div class="tags-container" id="tagsContainer"></div>
                            <textarea style="width: 100%; height: 400px" class="editor-content" placeholder="당신의 이야기를 적어보세요..." name="content" th:field="*{content}" required></textarea>
                            <input type="hidden" id="published" name="published" th:field="*{published}" value="false">
                            <input type="hidden" id="tags" name="tags" th:field="*{tags}">
                            <input type="hidden" id="postId" th:value="${postId}"> <!-- Hidden field to store postId -->
                    
                            <div class="editor-footer">
                                <button class="back-button" type="button" th:onclick="|location.href='@{/myblog}'|">나가기</button>
                                <div>
                                    <button type="button" id="saveDraftButton">임시저장</button>
                                    <button type="submit" id="publishButton">출간하기</button>
                                </div>
                            </div>
                        </form>
                    </div>
                    
                    <script>
                        document.addEventListener('DOMContentLoaded', function () {
                            const tagInput = document.getElementById('tagInput');
                            const tagsContainer = document.getElementById('tagsContainer');
                            const tagsInput = document.getElementById('tags');
                            const publishedInput = document.getElementById('published');
                            const postId = document.getElementById('postId').value; // Post ID 가져오기
                    
                            let tags = [];
                    
                            tagInput.addEventListener('click', function () {
                                alert("태그는 엔터키로 구분합니다.");
                            });
                    
                            tagInput.addEventListener('keydown', function (event) {
                                if (event.key === 'Enter') {
                                    event.preventDefault();
                                    const tag = tagInput.value.trim();
                    
                                    if (tag && !tags.includes(tag)) {
                                        fetch('/writeform/next/' + postId + '/addTag', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json'
                                            },
                                            body: JSON.stringify({ tagName: tag })
                                        })
                                            .then(response => response.json())
                                            .then(data => {
                                                if (data && data.id) {
                                                    tags.push(tag);
                                                    addTag(tag, data.id);
                                                    tagInput.value = '';
                                                } else {
                                                    console.error('Failed to add tag');
                                                }
                                            });
                                    }
                                }
                            });
                    
                            function addTag(tag, tagId) {
                                const tagItem = document.createElement('div');
                                tagItem.className = 'tag-item';
                                tagItem.textContent = tag;
                    
                                const removeButton = document.createElement('button');
                                removeButton.textContent = 'x';
                                removeButton.addEventListener('click', function () {
                                    tagsContainer.removeChild(tagItem);
                                    tags = tags.filter(t => t !== tag);
                    
                                    fetch('/writeform/next/' + postId + '/removeTag/' + tagId, {
                                        method: 'DELETE',
                                        headers: {
                                            'Content-Type': 'application/json'
                                        }
                                    }).then(response => {
                                        if (!response.ok) {
                                            console.log('Failed to delete tag');
                                        }
                                    });
                                });
                    
                                tagItem.appendChild(removeButton);
                                tagsContainer.appendChild(tagItem);
                            }
                    
                            document.getElementById('saveDraftButton').addEventListener('click', function () {
                                publishedInput.value = 'false';
                                tagsInput.value = tags.join(',');
                                document.getElementById('postForm').submit();
                            });
                    
                            document.getElementById('publishButton').addEventListener('click', function () {
                                publishedInput.value = 'true';
                                tagsInput.value = tags.join(',');
                            });
                    
                            document.getElementById('postForm').addEventListener('submit', function () {
                                tagsInput.value = tags.join(',');
                            });
                        });
                    </script>
                    </body>
                    </html>
                    
                    ```
                    
                - 2차
                    - 1차에서 json으로 필 때 고민..
            
        - JavaScript에서 keydown 이벤트시, 한글 두번 실행되는 에러..
            
            https://www.inforum24.com/memos/714
            
        - *{tags} 매핑 과정이 궁금했다.
            
            Thymeleaf와 Java Spring을 사용할 때, Java에서는 클라이언트로부터 전달받은 데이터를 서버 쪽에서 List<String> 형태로 자동으로 변환할 수 있습니다. 이 과정은 다음과 같은 원리로 동작합니다:
            
            1. **HTML 폼 제출**:
                - 사용자가 '하니', '귀여워' 태그를 입력하고 폼을 제출하면, JavaScript는 `tags` 배열을 콤마(,)로 구분된 문자열로 변환합니다.
                - 예를 들어, `tagsInput.value = tags.join(',');` 코드가 실행되면 `tags` 배열은 "하니,귀여워"와 같이 변환됩니다.
            2. **서버로 데이터 전송**:
                - 변환된 문자열은 `<input type="hidden" id="tags" name="tags" th:field="*{tags}">` 태그를 통해 폼 데이터로 전송됩니다.
                - `tags` 필드에 해당 문자열이 할당되고, 이 폼 데이터는 서버로 전송됩니다.
            3. **서버 측에서 데이터 매핑**:
                - 서버 측에서는 해당 필드를 List<String> 타입으로 받습니다.
                - Spring은 기본적으로 콤마로 구분된 문자열을 자동으로 List<String> 타입으로 변환해줍니다.
        
    - 두번째 입력폼 완성할 것! - 0705 완성
        - 공개글 / 비공개글에 대한 예제 - 지피티
            
            다음 코드 예제는 공개글,비공개글 설정이 published 로 생각한 경우..
            
            ### Filtering Posts Based on Visibility
            
            To filter posts based on their visibility (e.g., to only show public posts), you can add a query method in your `PostRepository`:
            
            ```java
            java코드 복사
            public interface PostRepository extends JpaRepository<Post, Long> {
                List<Post> findByPublishedTrue();
            }
            
            ```
            
            Then, use this method in your service to fetch only public posts:
            
            ```java
            java코드 복사
            @Service
            public class PostService {
            
                @Autowired
                private PostRepository postRepository;
            
                public List<Post> getPublicPosts() {
                    return postRepository.findByPublishedTrue();
                }
            }
            
            ```
            
        - post 미리보기사진 업로드 + 시리즈 / 포스트 사이 관계 설정
            - Post 미리보기 사진 업로드
                
                그리고, ajax 웬만하면 사용하지 말고..
                
                파일업로드 부분은
                
                html에서 form부분에 multipart 설정 넣어주고, input 타입을 file로 받으면.. 스프링에서 MultiPartFile이라고 되게 쉽게 해주는 애도 있고, FileService에서 해당 MulipartFile 넘기면 알아서 storefile 해주는 서비스까지 만들었으면서 안 쓰는 이유가 먼데 !!! 
                
            
            - 시리즈 / 포스트 사이 관계 설정 세팅
                - ‘시리즈 추가하기’ 버튼 누르면, 시리즈 엔디티에 있는 시리즈 목록 받아와서 보여줌 (fetchSeriesList() 함수 - ajax fetch로 GET /series 요청 보내서 List<String>으로 시리즈 리스트 받아옴)
                - input 태그로 입력받은 시리즈 이름을, 시리즈 목록 보여주게 렌더링하기 (addNewSeries())
                - input 태그 눌렀을 때 폼 제출 막아주기  (handleKeyPress())
                - 화면에 렌더링된 시리즈를 선택하면, hidden input 인 seriesName에 바인딩되게 해주기 !!
                    
                    (처음에 input 태그에서 모델로 넘긴 seriesName을 타임리프로 바인딩했는데, 너무 문제점이 많아서 생략함)
                    
                    - 코드
                        - **시리즈 선택을 위한 hidden input 추가**: `<input type="hidden" id="selectedSeries" name="seriesName">`을 추가하여 선택된 시리즈 이름을 저장합니다.
                        - **`addNewSeries` 함수**: 사용자가 새로운 시리즈 이름을 입력하고 "추가하기" 버튼을 누르면 시리즈 목록에 추가되고 화면에 렌더링됩니다.
                        - **`handleKeyPress` 함수**: input 태그에서 엔터를 눌렀을 때 폼 제출을 방지하고, 대신 시리즈를 추가하도록 합니다.
                        - **`selectSeries` 함수**: 사용자가 시리즈를 선택하면 hidden input에 시리즈 이름을 설정하고 모달을 닫습니다.
                
                이렇게 넘긴 2차 post 정보를 POST - /writeform/next/step에서 DB에 저장해준다.
                
                이때, 받아온 시리즈 - 포스트 엔디티 관계 매핑 설정은, 태그 때와 비슷하게 해준다.
                
            
        - redirect할 때 “/@{name}/{postTitle}로 함 - URL인코딩
            
            이때, user의 name이 한국말로 ‘유저1’이었는데 다음의 에러 발생 !!
            
            ```
            The HTTP response header [Location] with value 
            [http://localhost:8080/@유저1/post2] has been removed from the response 
            because it is invalid
            
            The Unicode character [유] at code point [50,976] cannot be encoded 
            as it is outside the permitted range of 0 to 255
            ```
            
            즉, 유니코드 문자가 포함된 URL을 처리하는데 문제가 있다.
            
            이를 해결하기 위해 URL 인코딩 활용 !
            
            `java.net.URLEncoder` 클래스를 활용해, 유니코드 문자를 URL 인코딩해서, 유니코드 문자를 안전하게 URL에 포함해보세요 !!
            
            이렇게 하면 유니코드 문자가 포함된 URL을 안전하게 처리할 수 있습니다. URL 인코딩을 통해 특수 문자와 유니코드 문자를 처리하는 방법을 사용하여 리다이렉트 URL을 생성하고, 해당 URL을 처리할 때 URL 디코딩을 통해 원래 값을 복원할 수 있습니다.
            
            - 적용코드
                
                ```java
                @PostMapping("/writeform/next/step")
                public String writeFormNextStep(@ModelAttribute(name = "postCreatedDto2") PostCreatedDto2 postCreatedDto2,
                    @SessionAttribute(name = SessionConst.User_Login_Form, required = false)UserLoginForm userLoginForm,
                    @RequestParam(name = "seriesName")String seriesName) throws IOException {
                
                    // 파일 저장
                    MultipartFile multipartFile = postCreatedDto2.getPreviewImage();
                    UploadFile previewImage = null;
                    if (multipartFile != null && !multipartFile.isEmpty()){
                        previewImage = fileStore.storeFile(multipartFile);
                    }
                
                    // DB에 저장
                    Post post = postService.findById(postCreatedDto2.getPostId());
                    post.setPreviewImage(previewImage);
                    post.setSubtitle(postCreatedDto2.getSubtitle());
                    post.setVisibility(postCreatedDto2.getVisibility());
                    post.setBlog(postService.findBlogByUserLoginForm(userLoginForm));
                
                    // 시리즈를 선택하지 않을수도 있음. 그냥 단순한 Post 일수도..
                    if (seriesName != null && !seriesName.isEmpty()){
                        Series series = seriesService.findBySeriesName(seriesName);
                
                        if (series == null){ // 새로운 시리즈 저장
                            series = new Series();
                            series.setSeriesName(seriesName);
                            seriesService.save(series);
                        }
                
                        post.setSeries(series); // Post - Series 연관관계 설정
                    }
                
                    postService.savePost(post); // post 2차까지 DB에 저장완료
                
                    User user = userService.findById(userLoginForm.getId());
                
                    // redirect할 때, username은 변경할 수 있으니까 안 바뀌는 'name' 속성으로 !!
                    String encodedUsername = URLEncoder.encode(user.getName(), StandardCharsets.UTF_8);
                    String encodedPostTitle = URLEncoder.encode(post.getTitle(), StandardCharsets.UTF_8);
                
                    return "redirect:/@" + encodedUsername + "/" + encodedPostTitle;
                }
                
                @GetMapping("/@{encodedUsername}/{encodedPostTitle}")
                public String showPost(@PathVariable String encodedUsername, @PathVariable String encodedPostTitle){
                    String decodedUsername = URLDecoder.decode(encodedUsername, StandardCharsets.UTF_8);
                    String decodedPostTitle = URLDecoder.decode(encodedPostTitle, StandardCharsets.UTF_8);
                
                    log.info("decodedUsername : {}", decodedUsername);
                    log.info("decodedPostTitle : {}", decodedPostTitle);
                
                    return "test";
                }
                ```
                
    
- Post 생성 완료 후, 특정 게시글 화면보여주기
    
    ![Untitled](Untitled%2010.png)
    
    [할 일 세팅 - 엔디티 관계 설정 먼저 차근차근 ]
    
    - 댓글 작성
        - ~~댓글 생성~~
        - ~~댓글 수정, 삭제 + 댓글 개수 동적 작용~~
    - ~~좋아요 늘리기 - 중복 좋아요 안되게끔~~  → 0709 완
        - 좋아요 기능
            
            ```
            like 엔디티에 id, post_id, user_id 를 설정해둠
            
            이를 통해, like - post - user 엔디티끼리 연관관계 설정해야 함 !!
            - like - post
            	>> 좋아요 개수는 post에 매핑된 like 개수..?
            
            - like - user
            	>> user_id로 user 식별해서, 좋아요 버튼 누르면 좋아요 버튼 눌린 상태 //
            		좋아요 한번 더 누르면 좋아요 취소되게끔..
            ```
            
        
        → `헷갈렸던 부분` 
        
        좋아요기능에서 user는 세션으로부터 로그인된 유저정보를 가져와야 하고,
        
        showPost에서 보여지는 유저정보는, 해당 post에 매핑된 블로그글이라 @PathVariable로 받아온 인코딩된 유저정보가 맞다.
        
        근데, 각 댓글의 작성자 정보는, 댓글을 작성할 당시의 유저정보를 보여줘야 한다 !!
        
        이를 위해 `댓글 엔티티에 작성자의 이름을 저장`하고, 댓글을 조회할 때 해당 정보를 사용했다.
        
        Comment 엔디티에 댓글작성자유저이름 필드를 추가했다. 이때, 댓글작성자유저이름은, 댓글 작성 당시 로그인했던 세선 유저정보를 사용했다.
        
        - `코드`
            
            ```java
            @GetMapping("/@{encodedUsername}/{encodedPostTitle}")
            public String showPost(@PathVariable String encodedUsername, @PathVariable String encodedPostTitle, Model model,
                                   @SessionAttribute(name = SessionConst.User_Login_Form, required = false)UserLoginForm userLoginForm){
                String decodedUsername = URLDecoder.decode(encodedUsername, StandardCharsets.UTF_8);
                String decodedPostTitle = URLDecoder.decode(encodedPostTitle, StandardCharsets.UTF_8);
            
                log.info("decodedUsername : {}", decodedUsername);
                log.info("decodedPostTitle : {}", decodedPostTitle);
            
                Post post = postService.findByTitle(decodedPostTitle); // post가 null일 경우, 에러 발생시키도록 postService에 설정해둠..
                User userBlog = userService.findByName(decodedUsername);// 이름만 username이고 넘긴 건 'name' -- 역시 에러 처리 userservice에 설정
                User userSession = userService.findById(userLoginForm.getId());
            
                model.addAttribute("post", post); // 저장된 post 정보
                model.addAttribute("userBlog", userBlog); // 블로그에 매핑된 유저정보
                model.addAttribute("userSession", userSession); // 현재 로그인한 유저정보
            
                return "post/showPost";
            }
            ```
            
            - PostController의 컨트롤러 코드에서 model에 userBlog, userSession 정보를 따로따로 저장함
            - userBlog는 인코딩된 유저name으로부터 얻은, Blog 엔디티에 매핑된 유저정보
            - userSession은 session으로부터 얻은 유저정보
            
            ```html
            <input type="hidden" id="post-id" th:value="${post.id}">
            <input type="hidden" id="user-id" th:value="${userSession.id}">
            ```
            
            - JavaScript 코드를 위해, user-id에, [userSession.id](http://userSession.id) 값을 저장함
            
            ```jsx
            // '댓글 작성' 버튼 누르면, 댓글 '생성' 추가
            document.querySelector('.comment-submit').addEventListener('click', function() {
                const content = document.querySelector('.comment-input').value;
                const postId = document.getElementById('post-id').value;
                const userId = document.getElementById('user-id').value;
            
                const payload = {
                    content: content,
                    postId: postId,
                    userId : userId // 댓글 작성할 때, 로그인한 유저정보(세션정보)를 알기 위해 !!
                };
            
                // POST /comments - 댓글 추가 api request 보내기
                fetch('/comments', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                }) 
            ```
            
            - 댓글 생성 JS 코드에 hidden변수로부터 얻은 userId를 추가해서, fetch 함수로 보낸다.
            
            ```java
            // CommentCreatedDTO
            @Data
            public class CommentCreatedDTO {
                private Long postId;
                private String content;
                private Long userId;  // 받은 userId 추가
            }
            
            // CommentService
            public Comment createComment(CommentCreatedDTO commentDTO){
            
                  Post post = postRepository.findById(commentDTO.getPostId())
                          .orElseThrow(() -> new PostNotFoundException("post not found with postId : " + commentDTO.getPostId()));
            
                  Optional<User> user = userRepository.findById(commentDTO.getUserId());
            
                  Comment comment = new Comment();
                  comment.setContent(commentDTO.getContent());
                  comment.setPost(post); // comment - post 연관관계 설정 !!
                  comment.setAuthorName(user.get().getName()); 
                  // 댓글 작성 당시, 세션 정보 저장 !!
            
                  return commentRepository.save(comment);
              }
              
            // CommentResponseDTO
            @Data
            @AllArgsConstructor
            public class CommentResponseDTO {
                private boolean success;
                private String content;
                private LocalDateTime updatedAt;
                // 댓글 수정하며 추가
                private Long commentId;
            
                private String authorName; // 댓글 작성 당시, 로그인한 유저닉네임 !!
            }
            
            // CommentController
            @PostMapping
            @ResponseBody
            public ResponseEntity<?> createComment(@RequestBody CommentCreatedDTO commentDTO){
            
                Comment comment = commentService.createComment(commentDTO);
            
                if (comment != null){ // comment, post 저장 성공
                    CommentResponseDTO commentResponseDTO =
                            new CommentResponseDTO(true, comment.getContent(), comment.getUpdatedAt(), comment.getId()
                            , comment.getAuthorName()); // 저장된 Comment 엔디티에서 authorName 받아오기..
            
                    return ResponseEntity.ok(commentResponseDTO);
                } else {
                    return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                            .body(new CommentResponseDTO(false, null, null, null, null));
                }
            }
            
            ```
            
            - CommentCreatedDTO - payload의 userId 변수 추가
            - CommentService에 댓글 작성 당시, 세션정보로부터 유저정보를 받아와 Comment의 authorName 필드에 저장한 후,
                
                CommentResponseDTO에 authorName을 담아 response를 보낸다.
                
            
            ```html
            newComment.innerHTML = `
                 <span class="comment-author">${data.authorName}</span>
            ```
            
            그럼 다시, showPost에서 댓글 추가할 때 넣을 코드에, CommentResponseDTO로부터 받은, authorName을 추가해 보여준다.
            
            또한, 이미 있는 댓글 정보를 보여줄 때는
            
            ```html
            <span class="comment-author" th:text="${comment.authorName}">작성자</span>
            ```
            
            comment 엔디티에 저장된 필드인 authorName을 보여줘야 한다 !!
            
        
    - 나머지
        - ~~화면 윗단부터 차례대로~~
        - ~~post 수정, 삭제 구현~~
        - ~~유저 정보 화면에 띄우기~~
    
    - JSON 무한재귀 사건 !! — 엔디티가 아닌 DTO를 사용해서 반환하는 이유 !!
        
        https://ahn3330.tistory.com/164
        
    

- 내 벨로그 → /myblog/{userid} - 0718 마무리
    
    [할일세팅]
    
    - 태그 중복되면, 태그 카운트로 보이게 (더이상 중복된 태그명은 화면에 뜨지 않게끔) →> 생각보다 빡세고 모르겠어서 다른 애들 처리한 다음에 돌아올 것 !!
        - TagService에 각 tagName - tagCount를 저장하는 hashMap을 만들어서 해결!
            - TagService
                
                ```java
                // 태그 중복 처리 -- 각각의 태그명 종류(tagName--String)와 개수(Integer) 카운팅
                public Map<String, Integer> getTagCounts(List<Post> posts){
                    Map<String, Integer> tagCountMap = new HashMap<>();
                
                    for (Post post : posts){
                        for (Tag tag : post.getTags()){
                            tagCountMap.put(tag.getTagName(),
                                    tagCountMap.getOrDefault(tag.getTagName(),0) + 1);
                
                            // Value - tagCountMap.getOrDefault() 부분을 통해, 현재 태그 이름 개수를 1 증가시킨다.
                            //       - 만일, tagCountMap에 해당 태그가 없다면, 기본값 0을 사용해서 1을 더한다.
                        }
                    }
                
                    return tagCountMap;
                }
                ```
                
            
            - postController - 모델에 tagCountMap 변수 추가
                
                ```java
                    @GetMapping("/@{encodedUsername}/posts")
                    public String showMyVelogPage(@PathVariable String encodedUsername, Model model,
                                                  @SessionAttribute(name = SessionConst.User_Login_Form, required = false)UserLoginForm userLoginForm){
                
                        User user = userService.findByName(encodedUsername);
                        Blog blog = postService.findBlogByUserLoginForm(userLoginForm);
                
                        List<Post> posts = blog.getPosts();
                        Map<String, Integer> tagCountMap = tagService.getTagCounts(posts);
                
                        model.addAttribute("user", user);
                        model.addAttribute("posts", posts);
                        model.addAttribute("encodedUsername", encodedUsername);
                        model.addAttribute("followerCount", user.getFollowers().size());
                        model.addAttribute("followingCount", user.getFollowings().size());
                        model.addAttribute("tagCountMap", tagCountMap);
                
                        return "post/showMyVelog";
                    }
                ```
                
            
            - 뷰 화면단에도 showMyVelog.html → 태그명 (태그개수) 로 출력되게끔 수정
                
                ```html
                <!-- 태그 목록 -->
                <div class="tags">
                    <h3>태그 목록</h3>
                    <ul class="tag-list">
                        <li th:each="tagEntry : ${tagCountMap}">
                            <a th:href="@{/tags/{tag} (tag=${tagEntry.key})}">
                                <span th:text="${tagEntry.key}">Tag Name</span>
                                (<span th:text="${tagEntry.value}">0</span>)
                            </a>
                        </li>
                    </ul>
                </div>
                ```
                
        
    - ~~팔로워, 팔로잉 엔디티 설정 완~~
        
        → 팔로워, 팔로잉 엔디티 채우는 기능도 메인이었지만
        
        →  팔로우 여부를 저장하고 페이지를 새로고침했을 때 팔로잉 상태를 유지하기도 해야 함. 
        
        서버에서, 현재 로그인한 사용자가, 해당 블로그의 작성자를 팔로우하고 있는지 확인하는 로직 추가해야 했음 .. 
        
    
    - ~~시리즈 섹션 보기~~
        - 시리즈 누르면, 해당 시리즈 글 보이게끔
    
    - ~~태그 누르면, 해당 태그에 해당하는 포스트들 보이기~~
        - 태그 목록 클릭시, 해당 태그를 가진 포스트를 필터링하고 + 선택된 태그에 초록불이 들어오게끔 수정
    
    - ~~시리즈 삭제, 수정 기능~~
        - 시리즈 삭제 시 주의점 !! — 연관 관계를 분리한 후 포스트들을 명시적으로 저장하고, 그 이후에 시리즈를 삭제하는 것
            - [ cascade all 주의점 ] Series만 삭제하고, 연관된 Post 엔디티들은 삭제하고 싶지 않았다.
                
                ```java
                // Series 엔디티 일부
                    @OneToMany(mappedBy = "series", cascade = CascadeType.ALL, orphanRemoval = true)
                    private List<Post> posts;
                
                // post 엔디티 일부
                		@ManyToOne
                    @JoinColumn(name = "series_id")
                    private Series series;
                ```
                
                - CascadeType.ALL 속성에 주목해보자 !
                    
                    **CascadeType.ALL**:
                    
                    - `Series` 엔티티에 대한 모든 영속성 전이 작업(저장, 병합, 삭제 등)이 `Post` 엔티티에도 전이됩니다.
                    - `Series`를 저장하면 관련된 모든 `Post` 엔티티도 저장됩니다.
                    - `Series`를 삭제하면 관련된 모든 `Post` 엔티티도 삭제됩니다.
                    
                    다시 말해,
                    
                    Series 엔디티를 삭제할 때는 Post 엔디티들은 삭제되지 않지만,
                    
                    cascade 설정으로 인해, Post 엔디티들이 수정(add/delete)될 때는, Series도 같이 영속성 전이가 돼서, 삭제된다! 
                    
                    하지만, 나는 Series만 지우고, 해당 시리즈에 해당했던 Post들은 지우고 싶지 않았으므로..
                    
                    그래서 series를 삭제할 때, 연관된 post들을 전부 null로 설정해서 분리시켰다!!
                    
                
                - 그리고 나서, cascade all 설정도 같이 지워줘야 했따 !!!!!
                    - 수정한 코드
                        - 엔디티
                            
                            ```java
                            // cascade, orphan 설정 없앰
                            @Entity
                            @Table(name = "series")
                            @Getter @Setter
                            @NoArgsConstructor
                            public class Series {
                                @Id
                                @GeneratedValue(strategy = GenerationType.IDENTITY)
                                private Long id;
                            
                                private String seriesName;
                            
                                @OneToMany(mappedBy = "series")
                                private List<Post> posts;
                            }
                            ```
                            
                        - 서비스 + 컨트롤러
                            
                            ```java
                            // SeriesService
                            @Transactional
                            public void deleteSeries(Long seriesId) {
                                Series series = seriesRepository.findById(seriesId)
                                        .orElseThrow(() -> new SeriesNotFoundException("Series not found with id :: " + seriesId));
                            
                                List<Post> posts = series.getPosts();
                                for (Post post : posts) {
                                    post.setSeries(null);
                                    postRepository.save(post); // 변경사항 저장
                                }
                            
                                seriesRepository.delete(series); // 시리즈 삭제
                            }
                            
                            // /series/${seriesId}/delete
                            @DeleteMapping("/series/{seriesId}/delete")
                            @ResponseBody
                            public ResponseEntity<?> deleteSeries(@PathVariable Long seriesId){
                                seriesService.deleteSeries(seriesId);
                            
                                return ResponseEntity.ok().build();
                            }
                            ```
                            
        - 시리즈 수정 → 406 Not Acceptable 에러
            
            https://woo-chang.tistory.com/39
            
            위 글을 읽어보면, fetch 함수에서 json 객체로 변환한 이후에, data.newSeriesName으로 값을 가져올 때, 내가 컨트롤러에서 responsdDto에 정의한 getter를 써야 했는데, 내가 getter 안 써와서 값을 못 받아왔음.
            
            - 코드
                
                ```java
                // SeriesController
                    @PatchMapping("/series/{seriesId}/update")
                    @ResponseBody
                    public ResponseEntity<?> updateSeriesName(@PathVariable Long seriesId,
                                                              @RequestBody UpdateSeriesNameRequestDto updateSeriesNameRequestDto){
                
                        log.info("수정 후 :: seriesNewName :: {}", updateSeriesNameRequestDto.getSeriesName());
                
                        // 시리즈 이름 업데이트 서비스 호출 등 필요한 로직 추가
                        seriesService.updateSeriesName(seriesId, updateSeriesNameRequestDto.getSeriesName());
                
                        UpdateSeriesNameResponseDto updateSeriesNameResponseDto = new UpdateSeriesNameResponseDto(
                                updateSeriesNameRequestDto.getSeriesName()
                        );
                
                        return ResponseEntity
                                .status(HttpStatus.OK)
                                .body(updateSeriesNameResponseDto);
                    }
                
                    @Getter
                    @NoArgsConstructor
                    static class UpdateSeriesNameRequestDto {
                        private String seriesName;
                    }
                
                    @NoArgsConstructor
                    @AllArgsConstructor
                    @Setter @Getter
                    static class UpdateSeriesNameResponseDto {
                        private String newSeriesName;
                    }
                ```
                
                ```jsx
                fetch(`/series/${seriesId}/update`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json' // 서버가 JSON 응답을 기대하도록 설정
                    },
                    body: JSON.stringify(
                        { seriesName: newSeriesName } // input 창으로 입력한 SeriesName을 넘겨준다
                    )
                }).then(response => {
                    if (response.ok) {
                        return response.json(); // JSON 응답을 받아오기 위해 추가 !!!
                    } else {
                        throw new Error("시리즈 이름 수정에 실패했습니다.");
                    }
                }).then(data => {
                    document.getElementById('series-title').textContent = 
                	    data.newSeriesName;
                
                    document.getElementById('series-title').style.display = 'inline';
                    document.getElementById('series-title-input').style.display = 'none';
                    document.getElementById('edit-button').style.display = 'inline';
                    document.getElementById('apply-button').style.display = 'none';
                }).catch(error => {
                    alert(error.message);
                });
                });
                ```
                
            

[2. 드롭다운 완]

---

### 3. 메인페이지 → 0717 완

- 메인화면
    - ~~블로그 글 목록 보기 (좋아요순, 최신순)~~
        
        https://velog.io/@kimdy0915/JPA-Spring-Data-Jpa-Pageable로-Pagination-쉽게-구현하기
        
        - 페이징 처리 코드 흐름 !!
            
            `Page<PostPagingResponseDTO>`를 사용하여 포스트 목록을 정렬할 수 있습니다. 이를 위해 몇 가지 수정이 필요합니다:
            
            1. **DTO 클래스** 추가 및 수정 → json으로 넘길 때 엔디티 아닌 DTO로 넘겨주세욥
            2. **PostRepository** 인터페이스 수정 → spring data jpa로, 정렬기준(좋아요순, 최신순) 정렬에 따른 Page<Post> 객체를 리턴해줍니다.
                
                → 이때, Page<Post>에서 Page는 내가 page를 0부터 10개씩 가져오게 설정했다면, 정렬기준에 맞게 10개씩 Post를 가져온다 !!
                
            3. **PostService** 클래스 수정
                
                → 정렬기준에 맞는 Page<Post>를 설정해, 최종리턴은 Page<PostPagingResponseDTO>로 리턴하게끔 합니다.
                
            4. **Controller** 수정
                
                → Pageable 인터페이스를 리턴하기 위해, PageRequest 구현체로 구현한 후, 해당 pageable을 postService에게 넘겨 기능을 위임시킨다 !
                
            5. **Frontend** 수정
                
                → 받은 Page<PagePagingResponseDTO>를 fetch에서 html innerHtml롤 화면에 보여주게 합니당
                
            
            ### 1. DTO 클래스
            
            ```java
            java코드 복사
            import lombok.Getter;
            import lombok.Setter;
            
            import java.time.LocalDateTime;
            
            @Getter
            @Setter
            public class PostPagingResponseDTO {
                private Long id;
                private String title;
                private String subtitle;
                private String username;
                private LocalDateTime updatedAt;
                private int likeCount;
                private String previewImage;
            
                public PostPagingResponseDTO(Post post) {
                    this.id = post.getId();
                    this.title = post.getTitle();
                    this.subtitle = post.getSubtitle();
                    this.username = post.getBlog().getUser().getUsername();
                    this.updatedAt = post.getUpdatedAt();
                    this.likeCount = post.getLikeCount();
                    this.previewImage = post.getPreviewImage() != null ? post.getPreviewImage().getStoreFileName() : null;
                }
            }
            
            ```
            
            ### 2. PostRepository 인터페이스
            
            ```java
            java코드 복사
            import org.springframework.data.domain.Page;
            import org.springframework.data.domain.Pageable;
            import org.springframework.data.jpa.repository.JpaRepository;
            import org.springframework.stereotype.Repository;
            
            @Repository
            public interface PostRepository extends JpaRepository<Post, Long> {
                Page<Post> findAllByOrderByLikeCountDesc(Pageable pageable);
                Page<Post> findAllByOrderByUpdatedAtDesc(Pageable pageable);
            }
            
            ```
            
            ### 3. PostService 클래스
            
            ```java
            java코드 복사
            import org.springframework.beans.factory.annotation.Autowired;
            import org.springframework.data.domain.Page;
            import org.springframework.data.domain.Pageable;
            import org.springframework.stereotype.Service;
            
            @Service
            public class PostService {
            
                @Autowired
                private PostRepository postRepository;
            
                public Page<PostPagingResponseDTO> getPosts(Pageable pageable, String sort) {
                    Page<Post> posts;
                    if ("recent".equals(sort)) {
                        posts = postRepository.findAllByOrderByUpdatedAtDesc(pageable);
                    } else {
                        posts = postRepository.findAllByOrderByLikeCountDesc(pageable);
                    }
                    return posts.map(PostPagingResponseDTO::new);
                }
            }
            
            ```
            
            ### 4. Controller 수정
            
            ```java
            java코드 복사
            import org.springframework.beans.factory.annotation.Autowired;
            import org.springframework.data.domain.Page;
            import org.springframework.data.domain.PageRequest;
            import org.springframework.data.domain.Pageable;
            import org.springframework.web.bind.annotation.GetMapping;
            import org.springframework.web.bind.annotation.RequestParam;
            import org.springframework.web.bind.annotation.RestController;
            
            @RestController
            public class PostController {
            
                @Autowired
                private PostService postService;
            
                @GetMapping("/posts")
                public Page<PostPagingResponseDTO> getPosts(
                        @RequestParam(defaultValue = "0") int page,
                        @RequestParam(defaultValue = "10") int size,
                        @RequestParam(defaultValue = "likes") String sort) {
                    Pageable pageable = PageRequest.of(page, size);
                    return postService.getPosts(pageable, sort);
                }
            }
            
            ```
            
            ### 5. Frontend 수정
            
            탭 클릭 시 Ajax 요청을 통해 데이터를 가져오도록 스크립트를 수정합니다.
            
            ```html
            html코드 복사
            <script>
                function switchTab(tab) {
                    document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
                    document.getElementById(`${tab}-tab`).classList.add('active');
            
                    const sort = tab === 'recent' ? 'recent' : 'likes';
                    fetch(`/posts?page=0&size=10&sort=${sort}`)
                        .then(response => response.json())
                        .then(data => {
                            const postContainer = document.getElementById('post-container');
                            postContainer.innerHTML = '';
                            data.content.forEach(post => {
                                postContainer.innerHTML += `
                                    <div class="post">
                                        <img src="${post.previewImage ? '/images/' + post.previewImage : '/images/default-previewImage.png'}" alt="미리보기 이미지" />
                                        <a href="/@${post.username}/${post.title}/blog">
                                            <div class="post-title">${post.title}</div>
                                        </a>
                                        <div class="post-subtitle">${post.subtitle}</div>
                                        <div class="post-meta">
                                            <div>${new Date(post.updatedAt).toLocaleDateString()}</div>
                                            <div>${post.username}</div>
                                            <div>❤️ ${post.likeCount}</div>
                                        </div>
                                    </div>
                                `;
                            });
                        });
                }
            
                document.addEventListener('DOMContentLoaded', function () {
                    switchTab('likes');
                });
            
                document.getElementById('trending-tab').addEventListener('click', function () {
                    switchTab('likes');
                });
            
                document.getElementById('recent-tab').addEventListener('click', function () {
                    switchTab('recent');
                });
            </script>
            
            ```
            
            위와 같이 수정하면 `Page<PostPagingResponseDTO>`를 사용하여 좋아요 순 또는 최신순으로 정렬된 포스트 목록을 페이징하여 클라이언트에 전달하고, 클라이언트에서 Ajax 요청을 통해 데이터를 받아와서 화면에 표시할 수 있습니다.
            
        
        → 단일 `Page<PostPagingResponseDTO>` 객체를 사용하여 한 번에 10개의 포스트를 최신순이나 좋아요순으로 정렬하여 가져오는 것이 일반적이고 효율적인 방식입니다. 이렇게 하면 사용자가 요청할 때마다 다른 페이지의 데이터를 가져올 수 있습니다
        
        그러니까, Page 객체에 설정한 0개의 post를 가져올 수 있는거임!
        `fetch(`/posts?page=0&size=10&sort=${sort}`)`
        
    - ~~무한 스크롤~~
    - ~~제목,내용,사용자 이름으로 검색 기능~~
        
        ![Untitled](Untitled%2011.png)
        

## 개인프로젝트 진행소감

```
- 기존에 이론으로만 알던 내용을 데이터베이스부터 설계해나가서, 생각보다 신경쓸 일이 많구나를 느꼈다.

- 하나의 프로젝트 완성이 성취감을 주었고, 다른 프로젝트도 실행해볼 수 있는 용기를 얻었다.

- 다만 아쉬운 점은,
	이번 프로젝트는 '구현과 경험'에만 집중했다보니, 코드 리팩토링할 부분이 많았다.
	
	예를 들면, 엔디티부분에서 다대다 관계를 다대일-일대다로 바꾸든지, 
	연관관계매핑을 굳이 단방향이 아닌 양방향으로 한다든지,
	디폴트로는 지연로딩 설정을 시키고 나중에 성능상 문제(N+1)가 발생할 때, fetch query를 날린다든지..
	고칠 부분이 많아서, 이 부분은 서서히 고쳐나가야될 것 같다.
```

---

---

## 4. 기타 - 후에 여유되면

- 대댓글 기능
- 마크다운 오픈소스 적용
    
    https://congsong.tistory.com/67
    

- 기타
    - 팔로우, 팔로워 누르면 어떤 유저가 팔로워 팔로우 중인지 보이는 화면
    - 임시글 - 저장목록 보기

---